
https://docs.google.com/document/d/1qc5f7lYc5r0qy0vDpqqJodHDNZXTr-yU_Xm3hXLkm68/edit

==========================================================
[Linux][binutils] Runtime Hack -- debugging with binutils
==========================================================

#11  <ETC>
-- How can I dump symbols in .la file on Ubuntu Linux?
-- 64bit mode 지원
-- 메모리 누수
-- Question?
#1  실행중인 프로세서에서 로드하고 있는 공유라이브러리 확인 및 메모리 로드 위치확인
#2  실행중인 프로세서의 절대경로 확인
#3  허가된 스택량 보기, 늘리기
#4  <LD_PRELOAD로 공유라이브러리 교체, symbol이 어느 라이브러리에 있는지 알아내기 'nm'>
#case 1
#case 2
#case 3
#5  Internal of 'ldd' (list dynamic dependencies)
-- 동적 라이브러리에서 dependency를 체크할 수 있는 방법
#6   공유(dynamic) 라이브러리 info
-- 동적 라이브러리의 세부동작 파악 유틸
-- 공유 라이브러리 생성
#7  -- 바이너리 파일에서 문자열 추출 : strings
#8  < binary section header & symbol table >
#9  debugging -- Objdump, ltrace, strace
#10  back trace address info -- addr2line  (파일명과 행번호로 표시)
Run-Time Hack Table
1.  실행중인 프로세서에서 로드하고 있는 공유라이브러리 확인 및 메모리 로드 위치확인
2.  실행중인 프로세서의 절대경로 확인
3.  허가된 스택량 보기, 늘리기
4.  ldd, LD_PRELOAD로 공유라이브러리 교체, symbol이 어느 라이브러리에 있는지 알아내기 'nm'
5. 동적 라이브러리
6. 바이너리 파일에서 문자열 추출 : strings
7. binary section header & symbol table
8. objdump를 이용한 디버깅
9. addr2line : 주소에서 파일명과 행 번호 얻기
10. rmalloc 설치, 사용방법, 동작원리 ( 동적 메모리 관리함수- malloc, calloc, realloc, free and strdup 디버깅)
11. gdb에서 where full 하면 호출체인에 포함된 지역변수까지 표시



#11  <ETC>

-- How can I dump symbols in .la file on Ubuntu Linux?
Anyway, to answer the question: .la is a libtool library. Usually it points to a .so file:
$ grep dlname libwebkit-1.0.la
dlname='libwebkit-1.0.so'
And then on the .so file you can use nm to show dynamic symbols:
$ nm -D libwebkit-1.0.so
...
If this is a C++ library, then you can use the -C flag to demangle the C++ function names.
$ nm -D -C libwebkit-1.0.so

[kyehwanl@node5 srx-0.2.0]$ grep dlname src/util/libutil.la     
dlname='libutil.so.0'

[kyehwanl@node5 srx-0.2.0]$ cat src/util/libutil.la            
# libutil.la - a libtool library file
# Generated by libtool (GNU libtool) 2.2.10

# The name that we can dlopen(3).
dlname='libutil.so.0'

# Names of this library.
library_names='libutil.so.0.0.0 libutil.so.0 libutil.so'

# The name of the static archive.
old_library='libutil.a'

# Libraries that this one depends upon.
dependency_libs=' -lpthread -ldl'
…

# Directory that this library needs to be installed in:
libdir='/users/kyehwanl/srx_test1/020-03/srx-0.2.0/test_install/lib'





-- 64bit mode 지원
- /proc/cpuinfo 의 내용을 살펴보면 64bit모드를 지원하는지 알 수 있다 --> flag행에 lm(Long Mode)이란 표기가 있으면 여부에 64모드를 지원한다



-- 메모리 누수
 top 을 실행했을때 가상메모리 사용량(VIRT, RES)가 시간에 따라 증가하는지를 알아내면 메모리 누수가 있는지 알 수 있음
- cat /proc/`pidof program`/maps --> program의 가상메모리를 출력



-- Question?
- object address를 알면 "objdump -Sl --no-show-raw-insn program" 으로 역어셈블 할수 있을까?

















Run-Time Hack 

#1  실행중인 프로세서에서 로드하고 있는 공유라이브러리 확인 및 메모리 로드 위치확인

/proc/self or <pid> /maps     --> pmap command 와 동일

<Example> 
gdb를 통해 bgp_read를 어디서 호출했는지 알아내려고 할때, 아래와 같이 나왔을경우 caller가 어디에 있는 함수인지 알 수 없을경우,
(gdb) up
 0xb7fa36e4 in ?? ()
(gdb) down
 0x0015db8e in bgp_read (thread=0xbffff530) at bgp_packet.c:2437

-->pmap을 확인
bgp2 [615]{.../bgpd/.libs}-> sudo cat /proc/`pidof lt-bgpd`/maps
00110000-001cc000 r-xp 00000000 08:01 2497640    /projects/srx/020-03/quagga-0.99.16-srx-0.2/bgpd/.libs/lt-bgpd
001cc000-001dd000 rw-p 000bb000 08:01 2497640    /projects/srx/020-03/quagga-0.99.16-srx-0.2/bgpd/.libs/lt-bgpd
001dd000-002c4000 rw-p 00000000 00:00 0          [heap]
b7ce5000-b7d06000 rw-p 00000000 00:00 0 
b7d06000-b7d12000 r-xp 00000000 08:01 44879      /lib/libnss_files-2.12.so
b7d12000-b7d13000 r--p 0000b000 08:01 44879      /lib/libnss_files-2.12.so
b7d13000-b7d14000 rw-p 0000c000 08:01 44879      /lib/libnss_files-2.12.so
...
b7f82000-b7f84000 rw-p 00000000 00:00 0 
b7f85000-b7fd5000 r-xp 00000000 08:01 2497269    /projects/srx/020-03/quagga-0.99.16-srx-0.2/lib/.libs/libzebra.so.0.0.0
b7fd5000-b7fdc000 rw-p 0004f000 08:01 2497269    /projects/srx/020-03/quagga-0.99.16-srx-0.2/lib/.libs/libzebra.so.0.0.0
...
b7fe0000-b7ffe000 r-xp 00000000 08:01 9035       /lib/ld-2.12.so
b7ffe000-b7fff000 r--p 0001d000 08:01 9035       /lib/ld-2.12.so
b7fff000-b8000000 rw-p 0001e000 08:01 9035       /lib/ld-2.12.so
bffeb000-c0000000 rw-p 00000000 00:00 0          [stack]

--> 그 후 addr2line -f or objdump를 이용하여 알아냄

 objdum 이용방법:
    (1) unknown function addr: 0xb7fa36e4
    (2) libzebra.so 시작주소: b7f85000
         (3) offset = (1) - (2) = 0x1E6E4
         (4) bgp2 [650]{.../lib/.libs}-> objdump -Sl libzebra.so.0.0.0 --start-address=0x1E6E4 | less

        Disassembly of section .text:
        0001e6e4 <thread_call+0x7f>:
        thread_call():
        /projects/srx/020-03/quagga-0.99.16-srx-0.2/lib/thread.c:1072

          GETRUSAGE (&thread->ru);
          (*thread->func) (thread);
            ...
        (5) 따라서 thread.c의 (*thread->func)() 에서 bgp_read를 호출했음



#2  실행중인 프로세서의 절대경로 확인

/proc/self or <pid> /exe : symbolic link --> absolute path
*심볼릭 링크값을 확인하기 위해서는 readlink(2)를 이용 (permission에 따라 root권한필요)
--> readlink /proc/self or <pid> /exe    

<example> readlink /proc/`pidof bgpd`/exe
*pidof <name> : name의 pid값을 return

*lsof -c 옵션, 어떤 특정한 프로그램의 프로세스들이 억세스하고 있는 모든 파일들을 볼 수 있다. (permission에 따라 root권한필요)
    lsof -c lt-bgpd 


#3  허가된 스택량 보기, 늘리기
$ ulimit -s
8192        <-- 8MB

$ ulimit -Ss 81920   <-- 10배로 늘렸다

이는 재귀적 함수 호출로 stack overflow가 생긴 프로그램의 스택량을 늘려서 overflow를 없애는데 사용될 수 있다.
예를 들어, /proc/<PID>/maps 를 열어서 stack의 범위가 0xbf06e000 ~ 0xbf86e000인데
아래와 같이 gdb를 통해 스택포인터가 스택의 범위를 벗어났을 경우임을 알 수 있다.

(gdb) p $sp  <-- stack pointer(SP) register
$1 = (void *) oxbf06dffc

* gdb에서 메모리맵을 볼려면 
(gdb) i proc mapping

* gdb에서 core, 코어덤프 분석의 경우는 /proc/<PID>/maps를 이용할 수 없는데 다음 명령을 통해 가능
(gdb) info files    or
(gdb) info target




#4  <LD_PRELOAD로 공유라이브러리 교체, symbol이 어느 라이브러리에 있는지 알아내기 'nm'>

#case 1

%hostname
akira.fsij.org

%ltrace hostname
gethostname("akira.fsij.org", 128)      =0
...

hostname에서 gethostname은 공유 라이브러리 libc.so.6에 있는 코드를 호출한다는 것을 ltrace를 통해 알수 있다.

[root@luka ~]#   nm -D /bin/hostname | grep gethostname (참고) -A or -o, --print-file-name: 해당심볼이 속한 오브젝트 파일명 출력
         U gethostname

[root@luka ~]# ldd /bin/hostname 
        linux-gate.so.1 =>  (0x005fc000)
        libselinux.so.1 => /lib/libselinux.so.1 (0x003c5000)
        libc.so.6 => /lib/libc.so.6 (0x001f0000)
        libdl.so.2 => /lib/libdl.so.2 (0x00362000)
        /lib/ld-linux.so.2 (0x001cd000)

[root@luka ~]# nm -D /lib/libc.so.6 | grep gethostname
002e6dd0 T __gethostname_chk
002c64e0 W gethostname

1. gethostname.so를 실험을 위해 만들때 int gethostname(..) 을 사용자정의한 함수로 만들고 컴파일하여 symbol로 만들어준다
2. LD_PRELOAD에 넣어주고 hostname 실행파일을 실행하면 
3. 라이브러리는 LD_PRELOAD로 명시한 gethostname.so에서 gethostname()함수의 심볼을 먼저 찾기때문에 libc.so.6에 있는 gethostname()심볼함수보다 
실행하는 것을 우선하게 하여 교체가능하다. 

!! 동적 링크할때는 기본적으로 먼저 발견한 심볼정의가 사용된다. --> [How to Write Shared Libraries] Ulrich Drepper

[root@luka ~]# LD_PRELOAD=./gethostname.so hostname (아래 부분”case 3” 설명 참고, preload multiple libraries 일때는 library간에 ‘:’을 붙인다)

or 
LD_PRELOAD= soname LD_LIBRARY_PATH=/path/to/library hostname (path 명시방법)

** 어떤 실행파일이 라이브러리를 찾지못할때 LD_PRELOAD 와 LD_LIBRARY_PATH를 각각 쓸수 있는데, 이때 LD_PRELOAD를 쓰게되면
    문자그대로 그 라이브러리가 다른 라이브러리보다 제일처음 로드되기때문에 문제를 일으킬수도 있다(ex. Segmentation fault). 
이때는 LD_LIBRARY_PATH를 쓰게되면 먼저 로드(preload)하게 되지않아서 정상적순서로 로드되어 문제가 없다.



#case 2

(1)MT unsafe 함수인 'localtime'을 어디서 쓰고 있는지 먼저 알아내고   (참고: nm -A, --print-file-name  Print name of the input file before every symbol)
ipx.antd [292]{.../0198-17/srx-0.2.0}-> find ./ -name '*.lo' -o -name '*.o' | xargs nm -A | grep "localtime"
...
./src/util/log.o:         U localtime    <-- undefined symbol (:다른 오브젝트 파일 또는 공유 라이브러리에 실재)
...

(2) 다시 확인
ipx.antd [303]{.../src/util}-> nm log.o
...   
00000001 C g_KH_type
         U localtime
000001b0 T logTimeStamp
...
(3) log.o를 이용해서 만들어낸 실행바이너리 or 라이브러리(libutil.a)의 dynamic linker dependency를 알아낸다
ipx.antd [309]{.../util/.libs}-> ldd libutil.so
        linux-gate.so.1 =>  (0x008e5000)
        libpthread.so.0 => /lib/libpthread.so.0 (0x00aa9000)
        libncurses.so.5 => /lib/libncurses.so.5 (0x00823000)
        libtinfo.so.5 => /lib/libtinfo.so.5 (0x00ae8000)
        libdl.so.2 => /lib/libdl.so.2 (0x008f3000)
        libc.so.6 => /lib/libc.so.6 (0x00110000)
        /lib/ld-linux.so.2 (0x007d4000)

(4) 위의 공유 라이브러리가 존재하는 /lib에서 다시 -A옵션(오브젝트파일이름출력)을 이용해 symbol 검색
ipx.antd [469]{/lib}-> nm -A *.so | grep localtime
libc-2.13.so:00881260 t __GI_localtime
libc-2.13.so:00881220 t __localtime_r
libc-2.13.so:00881260 T localtime
libc-2.13.so:0097ca74 b localtime_offset
libc-2.13.so:00881220 W localtime_r

(5) libc-2.13.so의 T (.text section)에 localtime의 실제 함수가 존재

*참고
ipx.antd [473]{/lib}-> ll libc*
lrwxrwxrwx  1 root root   12 Sep  7 18:04 libc.so.6 -> libc-2.13.so*  :(3)의 ldd에서 나온 libc.so.6은 libc-2.13.so의 symbolic link
...



#case 3
ipx.antd [549]{.../server/.libs}-> ldd srx_server
        linux-gate.so.1 =>  (0x00b73000)
        libutil.so.0 => not found
        libsrx.so.0 => not found
        libdl.so.2 => /lib/libdl.so.2 (0x0099e000)
        libpthread.so.0 => /lib/libpthread.so.0 (0x00981000)
        libconfig.so.9 => /srx_kyehwanl/020-03/srx-0.2.0/extras/files/libconfig-1.4.1/../../local/lib/libconfig.so.9 (0x00901000)
        libpatricia.so.0 => /srx_kyehwanl/020-03/srx-0.2.0/extras/files/libconfig-1.4.1/../../local/lib/libpatricia.so.0 (0x0040f000)
        libc.so.6 => /lib/libc.so.6 (0x00110000)
        /lib/ld-linux.so.2 (0x007d4000)

ipx.antd [551]{.../server/.libs}-> strings  srx_server
...
__bss_start
_end
/srx_kyehwanl/020-03/srx-0.2.0/test_install/lib:/srx_kyehwanl/020-03/srx-0.2.0/extras/files/libconfig-1.4.1/../../local/lib:/srx_kyehwanl/020-03/srx-0.2.0/extras/files/Net-Patricia-1.15/libpatricia/../../../local/lib
GLIBC_2.0
GLIBC_2.1
...

- preload multiple libraries 
 LD_PRELOAD=/srx_kyehwanl/020-03/srx-0.2.0/src/util/.libs/libutil.so.0:/srx_kyehwanl/020-03/srx-0.2.0/src/client/.libs/libsrx.so.0 ldd srx_server 
        linux-gate.so.1 =>  (0x00110000)
        /srx_kyehwanl/020-03/srx-0.2.0/src/util/.libs/libutil.so.0 (0x0077b000)
        /srx_kyehwanl/020-03/srx-0.2.0/src/client/.libs/libsrx.so.0 (0x00cfd000)
        libdl.so.2 => /lib/libdl.so.2 (0x0099e000)
        libpthread.so.0 => /lib/libpthread.so.0 (0x00981000)
        libconfig.so.9 => /srx_kyehwanl/020-03/srx-0.2.0/extras/files/libconfig-1.4.1/../../local/lib/libconfig.so.9 (0x004b1000)
        libpatricia.so.0 => /srx_kyehwanl/020-03/srx-0.2.0/extras/files/libconfig-1.4.1/../../local/lib/libpatricia.so.0 (0x00b15000)
        libc.so.6 => /lib/libc.so.6 (0x007f5000)
        /lib/ld-linux.so.2 (0x007d4000)


ipx.antd [546]{.../server/.libs}-> LD_PRELOAD=/srx_kyehwanl/020-03/srx-0.2.0/src/util/.libs/libutil.so.0:/srx_kyehwanl/020-03/srx-0.2.0/src/client/.libs/libsrx.so.0 ./srx_server
Start SRX Server Version 0.2
^Z
[1]+  Stopped                 LD_PRELOAD=/srx_kyehwanl/020-03/srx-0.2.0/src/util/.libs/libutil.so.0:/srx_kyehwanl/020-03/srx-0.2.0/src/client/.libs/libsrx.so.0 ./srx_server

ipx.antd [547]{.../server/.libs}-> ps aux | grep srx_server
kyehwanl 26462  0.0  0.0  30148   964 pts/3    Tl   03:58   0:00 ./srx_server

ipx.antd [548]{.../server/.libs}-> kill -9 `pidof srx_server`
[1]+  Killed                  LD_PRELOAD=/srx_kyehwanl/020-03/srx-0.2.0/src/util/.libs/libutil.so.0:/srx_kyehwanl/020-03/srx-0.2.0/src/client/.libs/libsrx.so.0 ./srx_server






#5  Internal of 'ldd' (list dynamic dependencies)
 : ldd 명령은 단순한 쉘 스크립트 
 
(1) 내부적으로 LD_TRACE_LOADED_OBJECS에 1을 설정하고 인수로 오는 프로그램을 실행
 
(2) 프로그램 실행시점에 ELF 인터프리터(런타임 로더 /lib/ld-linux.so.2)가 필요한 공유 라이브러리를 찾아
메모리에 로딩해서 그 정보를 표시한후, 실제 프로그램이 실행되기 전에 종료하게 된다. 




-- example for using LD_TRACE_LOADED_OBJECTS & LD_PRELOAD

[root@antl .libs]# LD_TRACE_LOADED_OBJECTS=1 ./srx_server 
        linux-gate.so.1 =>  (0x00d0c000)
        libutil.so.0 => /root/srx/install_test/lib/libutil.so.0 (0x00110000)
        libsrx.so.0 => /root/srx/install_test/lib/libsrx.so.0 (0x007b2000)
        libreadline.so.6 => /lib/libreadline.so.6 (0x00c54000)
        libncurses.so.5 => /lib/libncurses.so.5 (0x072f4000)
        libtinfo.so.5 => /lib/libtinfo.so.5 (0x0733a000)
        libdl.so.2 => /lib/libdl.so.2 (0x00ac4000)
        libpthread.so.0 => /lib/libpthread.so.0 (0x00aa7000)
        libconfig.so.9 => /root/srx/install_test/lib/libconfig.so.9 (0x0070f000)
        libpatricia.so.0 => /root/srx/install_test/lib/libpatricia.so.0 (0x00d69000)
        libc.so.6 => /lib/libc.so.6 (0x0091a000)
        /lib/ld-linux.so.2 (0x008f8000)

[root@antl .libs]# LD_TRACE_LOADED_OBJECTS=1 LD_PRELOAD=/usr/local/lib/libconfig.so.9 ./srx_server 
        linux-gate.so.1 =>  (0x00e51000)
        /usr/local/lib/libconfig.so.9 (0x00307000)
        libutil.so.0 => /root/srx/install_test/lib/libutil.so.0 (0x00f8b000)
        libsrx.so.0 => /root/srx/install_test/lib/libsrx.so.0 (0x00993000)
        libreadline.so.6 => /lib/libreadline.so.6 (0x00c54000)
        libncurses.so.5 => /lib/libncurses.so.5 (0x072f4000)
        libtinfo.so.5 => /lib/libtinfo.so.5 (0x0733a000)
        libdl.so.2 => /lib/libdl.so.2 (0x00ac4000)
        libpthread.so.0 => /lib/libpthread.so.0 (0x00aa7000)
        libpatricia.so.0 => /root/srx/install_test/lib/libpatricia.so.0 (0x00136000)
        libc.so.6 => /lib/libc.so.6 (0x0013a000)
        /lib/ld-linux.so.2 (0x008f8000)



-- 동적 라이브러리에서 dependency를 체크할 수 있는 방법
 → 실행파일과는 달리 동적 라이브러리는 실행이 불가능하므로 런타임링크(dynamic-liker)를 사용

    LD_TRACE_LOADED_OBJECTS=1  /lib/ld-linux.so.2  ./libxxx.so








#6   공유(dynamic) 라이브러리 info

- 공유라이브러리(shared library; so)를 이용하는 실행파일 또는 공유 라이브러리 자체는 이를 실행하려 할때 필요한 공유라이브러리에대한 정보를 갖고있다
    그 정보는 ELF의 동적 섹션의 NEEDED에 기록되어있다. 예를 들면 /bin/ls의 경우 objdump를 이용하면 다음과 같이 확인가능하다

 objdump -p /bin/ls ( or  readelf -d /bin/ls) 했을때 나타나는 공유라이브러리에서 
    ...
    Dynamic Section:
        NEEDED   libacl.so.1
        NEEDED     libtermcap.so.2
or 

 readelf -d lt-bgpd

Dynamic section at offset 0xd1ae0 contains 27 entries:
  Tag        Type                         Name/Value
 0x00000001 (NEEDED)                     Shared library: [libzebra.so.0]
 0x00000001 (NEEDED)                     Shared library: [libm.so.6]
 0x00000001 (NEEDED)                     Shared library: [libcrypt.so.1]
 0x00000001 (NEEDED)                     Shared library: [libpthread.so.0]
 0x00000001 (NEEDED)                     Shared library: [librt.so.1]
 0x00000001 (NEEDED)                     Shared library: [libc.so.6]
 0x0000000f (RPATH)                      Library rpath: [/users/kyehwanl/srx_test1/svn-trunk/quagga-trunk/lib/.libs:/users/kyehwanl/srx_test1/svn-trunk/quagga-trunk/test_install/lib]
 0x0000000c (INIT)                       0xa634
 0x0000000d (FINI)                       0x805d8


    NEEDED로 나타나는 것은 SONAME이므로, SONAME으로 부터 실제 파일을 찾아야 한다
        *일반적인경우 /usr/lib 또는 /lib에 SONAME에 해당하는 파일이 존재하는 경우 그것이 공유라이브러리 ( e.g., /usr/lib/libtermcap.so.x.y.z)
        *환경변수에 LD_LIBRARY_PATH에 경로로 설정한 경우 해당 디렉토리 참조
        */etc/ld.so.cache 의 정보 참조 <-- /etc/ld.so.conf의 설정을 이용해 ldconfig를 실행할때 갱신됨 

        *ldd(list dynamic dependencies) 를 사용하여 공유 라이브러리의 의존관계 개별적 확인 가능(#4 참조)

[root@terrain2 server]# ldd srx_server
        linux-gate.so.1 =>  (0x007bd000)
        libpthread.so.0 => /lib/libpthread.so.0 (0x001d4000)
        libconfig.so.9 => /home/brite/Downloads/AS50/srx/extras/local/lib/libconfig.so.9 (0x0097b000)
        libpatricia.so.0 => /home/brite/Downloads/AS50/srx/extras/local/lib/libpatricia.so.0 (0x00c59000)
        libc.so.6 => /lib/libc.so.6 (0x00452000)
        /lib/ld-linux.so.2 (0x00431000)

[root@terrain2 server]# LD_TRACE_LOADED_OBJECTS=1 ./srx_server
        linux-gate.so.1 =>  (0x0051b000)
        libpthread.so.0 => /lib/libpthread.so.0 (0x001d4000)
        libconfig.so.9 => /home/brite/Downloads/AS50/srx/extras/local/lib/libconfig.so.9 (0x00a93000)
        libpatricia.so.0 => /home/brite/Downloads/AS50/srx/extras/local/lib/libpatricia.so.0 (0x00add000)
        libc.so.6 => /lib/libc.so.6 (0x001ef000)
        /lib/ld-linux.so.2 (0x00431000)

ts1.antd [86]{.../src/server}-> ldd srx_server
        linux-gate.so.1 =>  (0x00c8e000)
        libpthread.so.0 => /lib/libpthread.so.0 (0x00602000)
        libconfig.so.9 => /srx/AS50/srx/extras/src/Net-Patricia-1.15/libpatricia/../../../local/lib/libconfig.so.9 (0x00e07000)
        libpatricia.so.0 => /srx/AS50/srx/extras/src/Net-Patricia-1.15/libpatricia/../../../local/lib/libpatricia.so.0 (0x002be000)
        libc.so.6 => /lib/libc.so.6 (0x00476000)
        /lib/ld-linux.so.2 (0x00455000)

 --아래는 autotools를 사용해서 bin를 만들었을경우.
ts1.antd [117]{.../src/server}-> ldd .libs/srx_server 
        linux-gate.so.1 =>  (0x005f1000)
        libutil.so.0 => /usr/local/lib/libutil.so.0 (0x00648000)
        libsrx.so.0 => /usr/local/lib/libsrx.so.0 (0x00ea0000)
        libreadline.so.6 => /lib/libreadline.so.6 (0x00674000)
        libncurses.so.5 => /lib/libncurses.so.5 (0x0348f000)
        libtinfo.so.5 => /lib/libtinfo.so.5 (0x03466000)
        libdl.so.2 => /lib/libdl.so.2 (0x0061f000)
        libpthread.so.0 => /lib/libpthread.so.0 (0x00602000)
        libconfig.so.9 => /usr/local/lib/libconfig.so.9 (0x004bd000)
        libpatricia.so.0 => /usr/local/lib/libpatricia.so.0 (0x008f7000)
        libc.so.6 => /lib/libc.so.6 (0x00110000)
        /lib/ld-linux.so.2 (0x00455000)


-- 동적 라이브러리의 세부동작 파악 유틸
- strace
- LD_DEBUG (좀더 강력한 디버깅툴)

ex) LD_DEBUG=files /bin/ls


-- 공유 라이브러리 생성
(1) 단일    
gcc -shared -fPIC -o foo.o foo.c

(2) 여러개를 하나로
gcc -fPIC -o testA.o testA.c
    gcc -fPIC -o testB.o testB.c
    gcc -shared -o final testA.o testB.o



#7  -- 바이너리 파일에서 문자열 추출 : strings
 
ts1.antd [55]{~}-> strings /etc/ld.so.cache | head -10 | grep xul
libxul.so
/usr/lib/xulrunner-1.9.2/libxul.so


ts1.antd [59]{~}-> strings -tx /etc/ld.so.cache | head -10 | grep xul    --> '-tx' : 문자열의 위치를 16진수출력
   7ab1 libxul.so
   7abb /usr/lib/xulrunner-1.9.2/libxul.so


ts1.antd [58]{~}-> cat /etc/ld.so.cache | strings | grep xul                
libxul.so
/usr/lib/xulrunner-1.9.2/libxul.so
/usr/lib/xulrunner-1.9.2/libxpcom.so
/usr/lib/xulrunner-1.9.2/libmozsqlite3.so
/usr/lib/xulrunner-1.9.2/libmozjs.so








#8  < binary section header & symbol table >

-- section header 

[root@terrain2 server]# readelf -S srx_server
There are 39 section headers, starting at offset 0x3e1fc:

Section Headers:
  [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al
  [ 0]                   NULL            00000000 000000 000000 00      0   0  0
  [ 1] .interp           PROGBITS        08048134 000134 000013 00   A  0   0  1
  [ 2] .note.ABI-tag     NOTE            08048148 000148 000020 00   A  0   0  4
  [ 3] .note.gnu.build-i NOTE            08048168 000168 000024 00   A  0   0  4
  [ 4] .gnu.hash         GNU_HASH        0804818c 00018c 00005c 04   A  5   0  4
  [ 5] .dynsym           DYNSYM          080481e8 0001e8 0006c0 10   A  6   1  4
  [ 6] .dynstr           STRTAB          080488a8 0008a8 000523 00   A  0   0  1
  [ 7] .gnu.version      VERSYM          08048dcc 000dcc 0000d8 02   A  5   0  2
  [ 8] .gnu.version_r    VERNEED         08048ea4 000ea4 000060 00   A  6   2  4
  [ 9] .rel.dyn          REL             08048f04 000f04 000038 08   A  5   0  4
  [10] .rel.plt          REL             08048f3c 000f3c 0002f0 08   A  5  12  4
    ...

-- symbol table

[root@terrain2 server]# readelf -s srx_server | less

Symbol table '.dynsym' contains 108 entries:
   Num:    Value  Size Type    Bind   Vis      Ndx Name
     0: 00000000     0 NOTYPE  LOCAL  DEFAULT  UND 
     1: 00000000     0 FUNC    GLOBAL DEFAULT  UND __errno_location@GLIBC_2.0 (2)
     2: 00000000     0 FUNC    GLOBAL DEFAULT  UND sigemptyset@GLIBC_2.0 (3)
     3: 00000000     0 FUNC    GLOBAL DEFAULT  UND inet_ntop@GLIBC_2.0 (3)
     4: 00000000     0 FUNC    GLOBAL DEFAULT  UND sprintf@GLIBC_2.0 (3)
     5: 00000000     0 FUNC    GLOBAL DEFAULT  UND pthread_cond_destroy@GLIBC_2.3.2 (4)
     6: 00000000     0 FUNC    GLOBAL DEFAULT  UND connect@GLIBC_2.0 (2)
        ...

이를 ELF헤더로 부터 찾아보면,
우선 section header에서 .dynsym이라는 심볼 테이블이 있다.

이를 덤프해 보면, 

[root@terrain2 server]# od --skip-bytes 0x1e8 --read-bytes 0x6c0 -t x1z srx_server (skip-byte는 offset을 고려)
0000750 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  >................<
0000770 85 00 00 00 00 00 00 00 00 00 00 00 12 00 00 00  >................<
0001010 70 03 00 00 00 00 00 00 00 00 00 00 12 00 00 00  >p...............<
0001030 22 03 00 00 00 00 00 00 00 00 00 00 12 00 00 00  >"...............<
...

심볼 테이블은 다음과 같은 구조체 테이블이다.
in case of 32bit,

 uint32_t       st_name;
 Elf32_Addr         st_value;
 uint32_t           st_size;
 unsigned char      st_info;
 unsigned char      st_other;
 uint16_t           st_shndx;

0번째 심볼 정보는 00 ...으로 비워져 있다 ( symbol table의 Num 0이 NOTYPE으로 비워져있다)
그 다음 심볼 정보는 다음과 같다.
85 00 00 00 00 00 00 00 00 00 00 00 12 00 00 00  >................<
st_name = 0x85 00 00 00 (왜냐면 대상 아키텍처(x86)가 리틀 엔디안이기 때문)
여기서 심볼명을 가리키는 옵셋값 st_name은 0x85,

.dynstr 섹션을 보면 스트링 테이블은 시작 위치로부터 0x8a8 바이트 떨어진 위치에서 시작함을 알 수 있다. (offset)
여기서 0x8a8에 0x85를 더한 값인 0x92d위치에서 시작하는 문자열을 보면 다음과 같이 __errno_location을 찾을수 있다.
[root@terrain2 server]# od --skip-bytes 0x92d --read-bytes 16 -t x1z srx_server 
0004455 5f 5f 65 72 72 6e 6f 5f 6c 6f 63 61 74 69 6f 6e  >__errno_location<
0004475

즉, st_name=0x85에 해당하는 심볼은 __errno_location임을 알 수 있다.
이는 readelf -s 의 심볼테이블의 두번째에 해당된다.








#9  debugging -- Objdump, ltrace, strace

--no-show-raw-insn : 기계어 니모닉정보 은폐  -Sl : 소스코드표시

objdump -Sl /usr/local/quagga/lib/libzebra.so.0 --start-address=0x13fd5 | less
objdump -Sl --no-show-raw-insn lt-bgpd --start-address=0x4268c | less
objdump -Sl --no-show-raw-insn /usr/local/quagga/lib/libzebra.so.0 --start-address=0x2ab56 | less




- ltrace: 공유 라이브러리의 함수호출 추적하기

- strace: system call tracer --> 설정파일이나 file open, 등과 같은 시스템콜 추적 가능, 시스템콜의 매개변수와 반환값 출력


- 현재의 레지스터 정보를 분석해서 
   (gdb) info reg

    rsp
    rip  0x3b4869ac80    0x3b4869ac80 <nanosleep+96>

    어떤명령을 실행하려고 했는지 살펴보자
    (gdb) x/i  0x3b4869ac80
        0x3b4869ac80        <nanosleep+96>:retq

    이는 retq명령, 즉 함수로 부터의 리턴명령이다 
    




#10  back trace address info -- addr2line  (파일명과 행번호로 표시)

- addr2line : 주소에서 파일명과 행 번호 얻기  →     addr2line -e <실행파일> -f <함수주소>
    어떤 파일의 출력이 특정함수의 주소를 출력한다고 가정하면 
    $gcc -g test.c
    $ ./a.out
    0x8048364

    $ addr2line -f -e a.out 0x8048364       : -f 함수명도 알수 있음
    func
    test.c:2    

GNU binutils에 포함된 addr2line을 이용하면 ELF 바이너리에 포함된 디버그 정보를 사용해서 
소스코드의 파일명과 행번호를 표시. (다음 "C로 back-trace 표시"를 통해 설명)

 <example> C로 back-trace 표시

glibc에 포함된 backtrace()와 backtrace_symbol_fd()를 이용하면 실행중인 C프로그램의 백트레이스를 출력할 수 있다.

----------------------------------------------------------------------
#include <execinfo.h>

void foo() {
    void *trace[128];
    int n = backtrace(trace, sizeof(trace) / sizeof(trace[0]));
    backtrace_symbols_fd(trace, n, 1); // STDOUT으로 출력
}

int main() {
    foo();
    return 0;
}
----------------------------------------------------------------------

$gcc -g -rdymanic
$./a.out 
./a.out(foo_0x1d)[0x8048659]
./a.out(main_0x15)[0x8048693]
/lib/libc.so.6(__libc_start_main+0xc7)[0x4002c8d7]
./a.out(backtrace_symbols_fd+0x31)[0x80485ad]

$ ./a.out | egrep -o '0x[0-9a-f]{7}' | addr2line -f  참고: [-e <executable file>]          
                                                                         -e가 생략되면 a.out으로 실행파일 인식
foo
/home/tmp/c/backtrace.c:5
main
/home/tmp/c/backtrace.c:11
??
??:0
_start
../sysdeps/i386/elf/start.S:83



<example2>  
--------------------------------
#include <stdio.h>
void func() { }
int main {
    printf("%p\n", &func);
    return 0;
}
--------------------------------

디버그 정보를 포함하도록 컴파일하여 실행하면 함수func의 주소가 표시된다.
$gcc -g test.c
$ ./a.out
0x8048364


$addr2line -f -e a.out 0x8048364
func
/tmp/test.c:2





Run-Time Hack Table

1.  실행중인 프로세서에서 로드하고 있는 공유라이브러리 확인 및 메모리 로드 위치확인
/proc/self or <pid> /maps       : pmap command 와 동일


2.  실행중인 프로세서의 절대경로 확인
/proc/self or <pid> /exe        : symbolic link --> absolute path
*심볼릭 링크값을 확인하기 위해서는 readlink(2)를 이용 (permission에 따라 root권한필요)
--> readlink /proc/self or <pid> /exe 
*lsof -c 옵션, 어떤 특정한 프로그램의 프로세스들이 억세스하고 있는 모든 파일들을 볼 수 있음

 
3.  허가된 스택량 보기, 늘리기
$ ulimit -s
8192        <-- 8MB
$ ulimit -Ss 81920   <-- 10배로 늘렸다


4.  ldd, LD_PRELOAD로 공유라이브러리 교체, symbol이 어느 라이브러리에 있는지 알아내기 'nm'
(1)MT unsafe 함수인 'localtime'을 어디서 쓰고 있는지 먼저 알아내고   (참고: nm -A, --print-file-name  Print name of the input file before every symbol)
find ./ -name '*.lo' -o -name '*.o' | xargs nm -A | grep "localtime"

(2) ldd 명령은 단순한 쉘 스크립트 →  내부적으로 LD_TRACE_LOADED_OBJECS에 1을 설정하고 인수로 오는 프로그램을 실행
(3) preload multiple libraries →  LD_PRELOAD=/.../libutil.so.0:/.../libsrx.so.0 ldd srx_server
# LD_TRACE_LOADED_OBJECTS=1 LD_PRELOAD=/usr/local/lib/libconfig.so.9 ./srx_server 

(4) 환경변수에 LD_LIBRARY_PATH에 경로로 설정한 경우 해당 디렉토리 참조
        */etc/ld.so.cache 의 정보 참조 <-- /etc/ld.so.conf의 설정을 이용해 ldconfig를 실행할때 갱신됨 ← /etc/ld.conf.d/파일.conf 를 만들어야됨


5. 동적 라이브러리
(1) 세부동작 파악 유틸:  LD_DEBUG (좀더 강력한 디버깅툴)  → ex) LD_DEBUG=files /bin/ls
(2) 동적 라이브러리에서 dependency를 체크  → 실행파일과는 달리 동적 라이브러리는 실행이 불가능하므로 런타임링크(dynamic-liker)를 사용
    LD_TRACE_LOADED_OBJECTS=1  /lib/ld-linux.so.2  ./libxxx.so
(3) 생성: gcc -shared -fPIC -o foo.o foo.c


6. 바이너리 파일에서 문자열 추출 : strings
strings /etc/ld.so.cache | head -10 | grep xul   or   cat /etc/ld.so.cache | strings | grep xul
strings -tx /etc/ld.so.cache | head -10 | grep xul    --> '-tx' : 문자열의 위치를 16진수출력


7. binary section header & symbol table
# readelf -S srx_server or readelf -s srx_server | less
# od --skip-bytes 0x1e8 --read-bytes 0x6c0 -t x1z srx_server (skip-byte는 offset을 고려)


8. objdump를 이용한 디버깅
objdump -Sl /usr/local/quagga/lib/libzebra.so.0 --start-address=0x13fd5 | less
objdump -Sl --no-show-raw-insn lt-bgpd --start-address=0x4268c | less


9. addr2line : 주소에서 파일명과 행 번호 얻기
    어떤 파일의 출력이 특정함수의 주소를 출력한다고 가정하면 
    $gcc -g test.c
    $ ./a.out
    0x8048364
    $ addr2line -f -e a.out 0x8048364       : -f 함수명도 알수 있음
    func
    test.c:2   
   $ ./a.out | egrep -o '0x[0-9a-f]{7}' | addr2line -f  참고: [-e <executable file>], -e가 생략되면 a.out으로 실행파일 인식


10. rmalloc 설치, 사용방법, 동작원리 ( 동적 메모리 관리함수- malloc, calloc, realloc, free and strdup 디버깅)
 (1) rmalloc 패키지에(www.hexco.de/rmdebug/) 포함된 rmalloc.c를 -c옵션으로 gcc로 컴파일해서 rmalloc.o 만들면 준비끝
 (2) 사용방법: debugging을 원하는 소스코드에 #define MALLOC_DEBUG 추가후 rmalloc패키지에 있는 rmalloc.h 인클루드, 그리고 rmalloc.o 링크


11. gdb에서 where full 하면 호출체인에 포함된 지역변수까지 표시





